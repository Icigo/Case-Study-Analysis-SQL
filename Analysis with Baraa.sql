SELECT * FROM [gold.dim_customers]
SELECT * FROM [gold.dim_products]
SELECT * FROM [gold.fact_sales]

-- Retrieve a list of unique countries from which customers originate

SELECT DISTINCT country
FROM [gold.dim_customers]
ORDER BY country

-- Retrieve a list of unique categories, subcategories, and products

SELECT DISTINCT category, subcategory, product_name 
FROM [gold.dim_products]
ORDER BY category, subcategory, product_name

-- Determine the first and last order date and the total duration in months

SELECT MIN(order_date) AS first_order, MAX(order_date) AS last_order, 
DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) AS total_duration_months
FROM [gold.fact_sales]

-- Find the youngest and oldest customer based on birthdate

SELECT MIN(birthdate) AS oldest_birthdate, DATEDIFF(YEAR, MIN(birthdate), GETDATE()) AS oldest_customer,
MAX(birthdate) AS youngest_birthdate, DATEDIFF(YEAR, MAX(birthdate), GETDATE()) AS youngest_customer 
FROM [gold.dim_customers]

-- Find the Total Sales

SELECT SUM(sales_amount) AS total_sales FROM [gold.fact_sales]

-- Find how many items are sold

SELECT SUM(quantity) AS total_items FROM [gold.fact_sales]

-- Find the average selling price

SELECT AVG(price) AS avg_selling_price FROM [gold.fact_sales]

-- Find the Total number of Orders

SELECT COUNT(DISTINCT order_number) AS total_orders FROM [gold.fact_sales]

-- Find the total number of products

SELECT COUNT(product_name) AS total_products FROM [gold.dim_products]

-- Find the total number of customers

SELECT COUNT(customer_id) AS total_customers FROM [gold.dim_customers]

-- Find the total number of customers that has placed an order

SELECT COUNT(DISTINCT customer_key) AS total_customers FROM [gold.fact_sales]

-- Generate a Report that shows all key metrics of the business

SELECT 'Total Sales' AS measure_name, SUM(sales_amount) AS measure_values FROM [gold.fact_sales]
UNION ALL
SELECT 'Total Items', SUM(quantity) FROM [gold.fact_sales]
UNION ALL
SELECT 'Avg Selling Price', AVG(price) FROM [gold.fact_sales]
UNION ALL
SELECT 'Total Orders', COUNT(DISTINCT order_number) FROM [gold.fact_sales]
UNION ALL
SELECT 'Total Products', COUNT(product_name) FROM [gold.dim_products]
UNION ALL
SELECT 'Total Customers', COUNT(customer_id) FROM [gold.dim_customers]

-- Find total customers by countries

SELECT country, COUNT(customer_id) AS total_customers
FROM [gold.dim_customers]
GROUP BY country
ORDER BY 2 DESC

-- Find total customers by gender

SELECT gender, COUNT(customer_id) AS total_customers
FROM [gold.dim_customers]
GROUP BY gender
ORDER BY 2 DESC

-- Find total products by category

SELECT category, COUNT(product_id) AS total_products
FROM [gold.dim_products]
GROUP BY category
ORDER BY 2 DESC

-- What is the average costs in each category?

SELECT category, AVG(cost) AS avg_cost
FROM [gold.dim_products]
GROUP BY category
ORDER BY 2 DESC

-- What is the total revenue generated for each category?

SELECT p.category, SUM(s.quantity * s.sales_amount) AS total_revenue 
FROM [gold.fact_sales] s
LEFT JOIN [gold.dim_products] p ON s.product_key = p.product_key
GROUP BY p.category
ORDER BY 2 DESC

-- What is the total revenue generated by each customer?

SELECT c.first_name, c.last_name, SUM(s.quantity * s.sales_amount) AS total_revenue 
FROM [gold.fact_sales] s
LEFT JOIN [gold.dim_customers] c ON s.customer_key = c.customer_key
GROUP BY c.first_name, c.last_name
ORDER BY 3 DESC

-- What is the distribution of sold items across countries?

SELECT c.country, SUM(s.quantity) AS total_sold_items 
FROM [gold.fact_sales] s
LEFT JOIN [gold.dim_customers] c ON s.customer_key = c.customer_key
GROUP BY c.country
ORDER BY 2 DESC

-- Which 5 products Generating the Highest Revenue?

SELECT TOP 5 p.product_name, SUM(s.quantity * s.sales_amount) AS total_revenue
FROM [gold.fact_sales] s
LEFT JOIN [gold.dim_products] p ON s.product_key = p.product_key
GROUP BY p.product_name
ORDER BY 2 DESC

-- What are the 5 worst-performing products in terms of sales?

SELECT TOP 5 p.product_name, SUM(s.quantity * s.sales_amount) AS total_revenue
FROM [gold.fact_sales] s
LEFT JOIN [gold.dim_products] p ON s.product_key = p.product_key
GROUP BY p.product_name
ORDER BY 2

-- Find the top 10 customers who have generated the highest revenue

SELECT TOP 10 c.first_name, c.last_name, SUM(s.quantity * s.sales_amount) AS total_revenue 
FROM [gold.fact_sales] s
LEFT JOIN [gold.dim_customers] c ON s.customer_key = c.customer_key
GROUP BY c.first_name, c.last_name
ORDER BY 3 DESC

-- The customers with the fewest orders placed

SELECT c.first_name, c.last_name, COUNT(DISTINCT s.order_number) AS total_orders 
FROM [gold.fact_sales] s
LEFT JOIN [gold.dim_customers] c ON s.customer_key = c.customer_key
GROUP BY c.first_name, c.last_name
HAVING COUNT(DISTINCT s.order_number) <= 1
ORDER BY c.first_name, c.last_name

-- Analyse sales performance over time

SELECT FORMAT(order_date, 'yyyy-MMM') AS order_date, SUM(sales_amount) AS total_sales, 
COUNT(customer_key) AS total_customers, SUM(quantity) AS total_quantity
FROM [gold.fact_sales]
WHERE order_date IS NOT NULL
GROUP BY FORMAT(order_date, 'yyyy-MMM')
ORDER BY 1

-- Calculate the total sales per month and the running total of sales over time and moving average

SELECT order_date, total_sales, 
SUM(total_sales) OVER(ORDER BY order_date) AS running_total_sales,
AVG(total_sales) OVER(ORDER BY order_date) AS moving_avg_sales
FROM (
	SELECT DATETRUNC(MONTH, order_date) AS order_date, SUM(sales_amount) as total_sales
	FROM [gold.fact_sales]
	WHERE order_date IS NOT NULL
	GROUP BY DATETRUNC(MONTH, order_date)
) k


/* Analyze the yearly performance of products by comparing their sales 
to both the average sales performance of the product and the previous year's sales */

WITH cte AS (
SELECT YEAR(s.order_date) AS order_year, p.product_name, SUM(s.sales_amount) AS current_sales
FROM [gold.fact_sales] s
LEFT JOIN [gold.dim_products] p ON s.product_key = p.product_key AND s.order_date IS NOT NULL
GROUP BY YEAR(s.order_date), p.product_name
)
SELECT order_year, product_name, current_sales,
AVG(current_sales) OVER(PARTITION BY product_name) AS avg_sales,
current_sales - AVG(current_sales) OVER(PARTITION BY product_name) AS diff_avg,
CASE 
	WHEN current_sales - AVG(current_sales) OVER(PARTITION BY product_name) > 0 THEN 'Above Avg'
	WHEN current_sales - AVG(current_sales) OVER(PARTITION BY product_name) < 0 THEN 'Below Avg'
	ELSE 'Avg'
END AS avg_change,
LAG(current_sales) OVER(PARTITION BY product_name ORDER by order_year) AS py_sales,
current_sales - LAG(current_sales) OVER(PARTITION BY product_name ORDER by order_year) AS diff_py_sales,
CASE
	WHEN current_sales - LAG(current_sales) OVER(PARTITION BY product_name ORDER by order_year) > 0 THEN 'Increase'
	WHEN current_sales - LAG(current_sales) OVER(PARTITION BY product_name ORDER by order_year) < 0 THEN 'Decrease'
	ELSE 'No Change'
END AS py_change
FROM cte
ORDER BY product_name, order_year

/*Segment products into cost ranges and 
count how many products fall into each segment*/

WITH cte AS (
SELECT product_key, product_name, cost,
CASE 
	WHEN cost < 100 THEN 'Less than 100'
	WHEN cost BETWEEN 100 AND 500 THEN '100-500'
	WHEN cost BETWEEN 500 AND 1000 THEN '500-1000'
	ELSE 'Above 1000'
END AS cost_range
FROM [gold.dim_products]
)
SELECT cost_range, COUNT(product_name) as total_products
FROM cte
GROUP BY cost_range
ORDER BY 2 DESC

/*Group customers into three segments based on their spending behavior:
	- VIP: Customers with at least 12 months of history and spending more than €5,000.
	- Regular: Customers with at least 12 months of history but spending €5,000 or less.
	- New: Customers with a lifespan less than 12 months.
And find the total number of customers by each group
*/

WITH cte AS (
SELECT c.customer_key, SUM(sales_amount) AS total_spending, MIN(s.order_date) AS first_order, MAX(s.order_date) AS last_order,
DATEDIFF(MONTH, MIN(s.order_date), MAX(s.order_date)) AS lifespan
FROM [gold.fact_sales] s
LEFT JOIN [gold.dim_customers] c ON s.customer_key = c.customer_key
GROUP BY c.customer_key
)
SELECT customer_segment, COUNT(customer_key) AS total_customers
FROM (
SELECT customer_key,
CASE 
	WHEN lifespan >= 12 AND total_spending > 5000 THEN 'VIP'
	WHEN lifespan >= 12 AND total_spending <= 5000 THEN 'Regular'
	WHEN lifespan < 12 THEN 'New'
END AS customer_segment
FROM cte
) o
GROUP BY customer_segment
ORDER BY total_customers DESC

-- Which categories contribute the most to overall sales?

WITH cte AS (
SELECT p.category, SUM(s.sales_amount) AS total_sales
FROM [gold.fact_sales] s
LEFT JOIN [gold.dim_products] p ON s.product_key = p.product_key
GROUP BY p.category
)
SELECT category, total_sales, SUM(total_sales) OVER() AS overall_sales,
ROUND(100 * CAST(total_sales AS FLOAT) / SUM(total_sales) OVER(), 2) AS percent_of_total
FROM cte
ORDER BY total_sales DESC

/*
===============================================================================
Customer Report
===============================================================================
Purpose:
    - This report consolidates key customer metrics and behaviors

Highlights:
    1. Gathers essential fields such as names, ages, and transaction details.
	2. Segments customers into categories (VIP, Regular, New) and age groups.
    3. Aggregates customer-level metrics:
	   - total orders
	   - total sales
	   - total quantity purchased
	   - total products
	   - lifespan (in months)
    4. Calculates valuable KPIs:
	    - recency (months since last order)
		- average order value
		- average monthly spend
===============================================================================
*/

WITH base_query AS (
SELECT s.order_number, s.product_key, s.order_date , s.sales_amount , s.quantity , c.customer_key, c.customer_number,
CONCAT(c.first_name, ' ', c.last_name) AS customer_name, DATEDIFF(YEAR, c.birthdate, GETDATE()) AS age 
FROM [gold.fact_sales] s
LEFT JOIN [gold.dim_customers] c ON s.customer_key = c.customer_key AND s.order_date IS NOT NULL
),
customer_aggregation AS (
SELECT customer_key, customer_number, customer_name, age, 
COUNT(DISTINCT order_number) AS total_orders, SUM(sales_amount) AS total_sales, SUM(quantity) AS total_quantity, 
COUNT(DISTINCT product_key) AS total_products, MAX(order_date) AS last_order_date, DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) AS lifespan
FROM base_query
GROUP BY customer_key, customer_number, customer_name, age
)
SELECT customer_key, customer_number, customer_name, age,
CASE 
	WHEN age < 20 THEN 'Under 20'
	WHEN age BETWEEN 20 AND 29 THEN '20-29'
	WHEN age BETWEEN 30 AND 39 THEN '30-39'
	WHEN age BETWEEN 40 AND 49 THEN '40-49'
	ELSE '50 and Above'
END AS age_group,
CASE 
	WHEN lifespan >= 12 AND total_sales > 5000 THEN 'VIP'
	WHEN lifespan >= 12 AND total_sales <= 5000 THEN 'Regular'
	WHEN lifespan < 12 THEN 'New'
END AS customer_segment,
last_order_date, DATEDIFF(MONTH, last_order_date, GETDATE()) AS recency_in_months, total_orders, total_sales, total_quantity, total_products, lifespan,
CASE WHEN total_sales = 0 THEN 0 ELSE total_sales / total_orders END AS avg_order_value,
CASE WHEN lifespan = 0 THEN total_sales ELSE total_sales / lifespan END AS avg_monthly_spend
FROM customer_aggregation;


/*
===============================================================================
Product Report
===============================================================================
Purpose:
    - This report consolidates key product metrics and behaviors.

Highlights:
    1. Gathers essential fields such as product name, category, subcategory, and cost.
    2. Segments products by revenue to identify High-Performers, Mid-Range, or Low-Performers.
    3. Aggregates product-level metrics:
       - total orders
       - total sales
       - total quantity sold
       - total customers (unique)
       - lifespan (in months)
    4. Calculates valuable KPIs:
       - recency (months since last sale)
       - average order revenue (AOR)
       - average monthly revenue
===============================================================================
*/

WITH base_query AS (
SELECT s.order_number, s.order_date, s.customer_key, s.sales_amount, s.quantity, 
p.product_key, p.product_name, p.category, p.subcategory, p.cost 
FROM [gold.fact_sales] s
LEFT JOIN [gold.dim_products] p ON s.product_key = p.product_key AND s.order_date IS NOT NULL
),
product_aggregation AS (
SELECT product_key, product_name, category, subcategory, cost, DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) AS lifespan,
MAX(order_date) AS last_sale_date, COUNT(DISTINCT order_number) AS total_orders, COUNT(DISTINCT customer_key) AS total_customers,
SUM(sales_amount) AS total_sales, SUM(quantity) AS total_quantity, 
ROUND(AVG(CAST(sales_amount AS FLOAT) / NULLIF(quantity, 0)), 1) AS avg_selling_price
FROM base_query
GROUP BY product_key, product_name, category, subcategory, cost
)
SELECT product_key, product_name, category, subcategory, cost, last_sale_date,
DATEDIFF(MONTH, last_sale_date, GETDATE()) AS recency_in_months,
CASE 
	WHEN total_sales > 50000 THEN 'High-Performer'
	WHEN total_sales >= 10000 THEN 'Mid-Range'
	ELSE 'Low-Performer'
END AS product_segment,
lifespan, total_orders, total_sales, total_quantity, total_customers, avg_selling_price,
CASE WHEN total_orders = 0 THEN 0 ELSE total_sales / total_orders END AS avg_order_revenue,
CASE WHEN lifespan = 0 THEN total_sales ELSE total_sales / lifespan END AS avg_monthly_revenue
FROM product_aggregation;

